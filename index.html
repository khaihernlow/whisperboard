<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Attendee Realtime Transcription Demo</title>
  <style>
    body{font-family:system-ui,Arial;margin:2rem}
    #log{white-space:pre-wrap;border:1px solid #ccc;padding:1rem;height:60vh;overflow:auto}
    #status{margin:1rem 0;padding:0.5rem;border:1px solid #ddd;border-radius:4px;background:#f9f9f9}
    .status-label{font-weight:bold;display:inline-block;margin-right:0.5rem}
    .status-value{color:#333}
    .status-ended{color:#e74c3c}
    .status-running{color:#27ae60}
    .status-starting{color:#f39c12}
    .status-error{color:#e74c3c}
  </style>
</head>
<body>
  <h1>Attendee Realtime Transcription Demo</h1>

  <label>
    Meeting URL:
    <input id="meetingUrl" size="60"
           placeholder="https://meet.google.com/abc-defg-hij..." />
  </label>
  <button id="startBtn">Launch Bot &amp; Start Transcribing</button>
  <button id="leaveBtn" style="display:none;margin-left:10px;background:#e74c3c;color:white;">Leave Meeting</button>


  <div id="zoomBanner" style="display:none;margin:0.5rem 0;padding:0.5rem;background:#e3f2fd;border:1px solid #bbdefb;border-radius:4px;color:#1565c0;font-size:0.9em;">
    üìπ <strong>Warning:</strong> You need to add Zoom and Deepgram credentials in your Attendee dashboard to join Zoom meetings.
    <br>
    <br>
    <a href="https://www.loom.com/share/7cbd3eab1bc4438fb1badcb3787996d6?sid=da6a46af-19e5-4196-9bfb-07152e6454fb" target="_blank" style="color:#1565c0;text-decoration:underline;">Watch this video</a> 
    to see how, or try a Google Meet or Microsoft Teams meeting instead (no credentials required).
  </div>
  <div id="status">
    <span class="status-label">Bot Status:</span>
    <span id="statusValue" class="status-value">Not started</span>
  </div>

  <div id="joiningBanner" style="display:none;margin:0.5rem 0;padding:0.5rem;background:#fff3cd;border:1px solid #ffeaa7;border-radius:4px;color:#856404;font-size:0.9em;">
    ‚è±Ô∏è It can take up to one minute for the bot to join the meeting
  </div>

  <h2>Conversation Analysis</h2>
  <div id="analysisControls" style="margin: 1rem 0; padding: 1rem; background: #f8f9fa; border-radius: 4px;">
    <button id="analyzeBtn" style="margin-right: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Analyze Conversation</button>
    <button id="createDiagramBtn" style="margin-right: 10px; padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Create Miro Diagram</button>
    <span id="analysisStatus" style="margin-left: 10px; color: #666;"></span>
  </div>
  
  <div id="analysisResults" style="display: none; margin: 1rem 0; padding: 1rem; background: #e8f5e8; border-radius: 4px; border: 1px solid #28a745;">
    <h3>Analysis Results</h3>
    <div id="analysisContent"></div>
  </div>

  <h2>Transcript</h2>
  <div id="log"></div>

  <script>
  const log           = document.getElementById("log");
  const meetingUrl    = document.getElementById("meetingUrl");
  const btn           = document.getElementById("startBtn");
  const leaveBtn      = document.getElementById("leaveBtn");
  const statusValue   = document.getElementById("statusValue");
  const joiningBanner = document.getElementById("joiningBanner");
  const zoomBanner    = document.getElementById("zoomBanner");
  
  // Analysis controls
  const analyzeBtn    = document.getElementById("analyzeBtn");
  const createDiagramBtn = document.getElementById("createDiagramBtn");
  const analysisStatus = document.getElementById("analysisStatus");
  const analysisResults = document.getElementById("analysisResults");
  const analysisContent = document.getElementById("analysisContent");

  let lastStatusTimestamp = null;
  let currentBotId = null;
  let pollingInterval = null;
  let lastTranscriptTime = 0;

  function updateStatus(state, eventType = null, timestamp = null) {
    // If we have a timestamp, check if it's newer than the last one
    if (timestamp && lastStatusTimestamp) {
      const newTime = new Date(timestamp);
      const lastTime = new Date(lastStatusTimestamp);
      if (newTime <= lastTime) {
        // Ignore older status updates
        return;
      }
    }
    
    // Update the last timestamp if provided
    if (timestamp) {
      lastStatusTimestamp = timestamp;
    }

    statusValue.textContent = state;
    statusValue.className = "status-value";
    
    // Show/hide joining banner
    if (state === "joining") {
      joiningBanner.style.display = "block";
    } else {
      joiningBanner.style.display = "none";
    }
    
    // Show/hide leave button based on state
    if (state === "joined_not_recording" || state === "joined_recording") {
      leaveBtn.style.display = "inline-block";
    } else {
      leaveBtn.style.display = "none";
    }
    
    // Add appropriate CSS class based on state
    if (state === "ended" || state === "fatal_error" || state === "data_deleted") {
      statusValue.classList.add("status-ended");

      btn.disabled = false;
      btn.textContent = "Launch Bot & Start Transcribing";
      currentBotId = null;
      stopPolling();

    } else if (state === "joined_recording") {
      statusValue.classList.add("status-running");
    } else if (state === "ready" || state === "joining" || state === "joined_not_recording" || 
               state === "leaving" || state === "post_processing" || state === "waiting_room") {
      statusValue.classList.add("status-starting");
    }
  }

  async function leaveBot() {
    if (!currentBotId) return;
    
    leaveBtn.disabled = true;
    leaveBtn.textContent = "Leaving...";
    stopPolling(); // Stop polling when leaving
    
    try {
      const resp = await fetch(`/leave/${currentBotId}`, {
        method: "POST",
        headers: {"Content-Type": "application/json"}
      });
      
      if (!resp.ok) {
        alert("Failed to leave: " + (await resp.text()));
        leaveBtn.disabled = false;
        leaveBtn.textContent = "Leave Meeting";
        startPolling(); // Restart polling if leave failed
      } else {
        // Successfully left, reset UI
        btn.disabled = false;
        btn.textContent = "Launch Bot & Start Transcribing";
        currentBotId = null;
        updateStatus("ended");
      }
    } catch (error) {
      alert("Failed to leave: " + error.message);
      leaveBtn.disabled = false;
      leaveBtn.textContent = "Leave Meeting";
      startPolling(); // Restart polling if leave failed
    }
  }

  // Polling functions instead of SSE
  async function pollBotStatus() {
    if (!currentBotId) return;
    
    try {
      const resp = await fetch(`/bot-status/${currentBotId}`);
      if (resp.ok) {
        const botData = await resp.json();
        updateStatus(botData.state);
      }
    } catch (error) {
      console.error("Error polling bot status:", error);
    }
  }

  async function pollTranscripts() {
    if (!currentBotId) return;
    
    try {
      const resp = await fetch(`/transcripts/${currentBotId}`);
      if (resp.ok) {
        const data = await resp.json();
        // The API returns an array directly, not wrapped in a 'transcripts' property
        if (Array.isArray(data)) {
          data.forEach(transcript => {
            if (transcript.timestamp_ms > lastTranscriptTime) {
              const ts = new Date(transcript.timestamp_ms).toLocaleTimeString();
              log.textContent += `[${ts}] ${transcript.speaker_name}: ${transcript.transcription.transcript}\n`;
              log.scrollTop = log.scrollHeight;
              lastTranscriptTime = transcript.timestamp_ms;
            }
          });
        }
      }
    } catch (error) {
      console.error("Error polling transcripts:", error);
    }
  }

  function startPolling() {
    if (pollingInterval) clearInterval(pollingInterval);
    pollingInterval = setInterval(async () => {
      await pollBotStatus();
      await pollTranscripts();
    }, 2000); // Poll every 2 seconds
  }

  function stopPolling() {
    if (pollingInterval) {
      clearInterval(pollingInterval);
      pollingInterval = null;
    }
  }

  btn.onclick = async () => {
    const url = meetingUrl.value.trim();
    if (!url) { alert("Enter a meeting URL"); return; }

    btn.disabled = true;
    btn.textContent = "Launching‚Ä¶";
    updateStatus("ready");

    const resp = await fetch("/launch", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({meeting_url: url}),
    });

    if (resp.ok) {
      const {bot_id} = await resp.json();
      updateStatus("joining");
      btn.disabled = true;
      btn.textContent = "Launched";
      // reset the leave button
      leaveBtn.disabled = false;
      leaveBtn.textContent = "Leave Meeting";
      currentBotId = bot_id;
      
      // Start polling for status and transcripts
      startPolling();
    } else {
      alert("Failed: " + (await resp.text()));
      btn.disabled = false;
      btn.textContent = "Launch Bot & Start Transcribing";
      updateStatus("fatal_error");
    }
  };

  leaveBtn.onclick = leaveBot;

  // Analysis functions
  async function analyzeConversation() {
    if (!currentBotId) {
      alert("No active bot. Please start a meeting first.");
      return;
    }
    
    analyzeBtn.disabled = true;
    analyzeBtn.textContent = "Analyzing...";
    analysisStatus.textContent = "Analyzing conversation with Gemini AI...";
    
    try {
      const resp = await fetch(`/analyze-conversation/${currentBotId}`, {
        method: "POST",
        headers: {"Content-Type": "application/json"}
      });
      
      const result = await resp.json();
      
      if (resp.ok && !result.error) {
        displayAnalysisResults(result);
        analysisStatus.textContent = "Analysis completed successfully!";
        analysisStatus.style.color = "#28a745";
      } else {
        analysisStatus.textContent = `Analysis failed: ${result.error || 'Unknown error'}`;
        analysisStatus.style.color = "#dc3545";
      }
    } catch (error) {
      analysisStatus.textContent = `Analysis failed: ${error.message}`;
      analysisStatus.style.color = "#dc3545";
    } finally {
      analyzeBtn.disabled = false;
      analyzeBtn.textContent = "Analyze Conversation";
    }
  }

  async function createMiroDiagram() {
    if (!currentBotId) {
      alert("No active bot. Please start a meeting first.");
      return;
    }
    
    createDiagramBtn.disabled = true;
    createDiagramBtn.textContent = "Creating...";
    analysisStatus.textContent = "Creating Miro diagram...";
    
    try {
      const resp = await fetch(`/create-diagram/${currentBotId}`, {
        method: "POST",
        headers: {"Content-Type": "application/json"}
      });
      
      const result = await resp.json();
      
      if (resp.ok && result.diagram && result.diagram.success) {
        analysisStatus.textContent = "Miro diagram created successfully!";
        analysisStatus.style.color = "#28a745";
        
        // Show the Miro board URL
        const miroLink = document.createElement("a");
        miroLink.href = result.diagram.board_url;
        miroLink.target = "_blank";
        miroLink.textContent = "Open Miro Board";
        miroLink.style.marginLeft = "10px";
        miroLink.style.color = "#007bff";
        
        analysisStatus.appendChild(miroLink);
        
        // Also display the analysis results
        if (result.analysis && !result.analysis.error) {
          displayAnalysisResults(result.analysis);
        }
      } else {
        const errorMsg = result.diagram?.error || result.error || 'Unknown error';
        analysisStatus.textContent = `Diagram creation failed: ${errorMsg}`;
        analysisStatus.style.color = "#dc3545";
      }
    } catch (error) {
      analysisStatus.textContent = `Diagram creation failed: ${error.message}`;
      analysisStatus.style.color = "#dc3545";
    } finally {
      createDiagramBtn.disabled = false;
      createDiagramBtn.textContent = "Create Miro Diagram";
    }
  }

  function displayAnalysisResults(analysis) {
    let html = "<div style='font-size: 0.9em;'>";
    
    if (analysis.topics && analysis.topics.length > 0) {
      html += "<h4>üìã Key Topics</h4><ul>";
      analysis.topics.slice(0, 5).forEach(topic => {
        html += `<li><strong>${topic.name}</strong> (${Math.round(topic.importance * 100)}% important)<br><small>${topic.description || ''}</small></li>`;
      });
      html += "</ul>";
    }
    
    if (analysis.decisions && analysis.decisions.length > 0) {
      html += "<h4>‚úÖ Decisions Made</h4><ul>";
      analysis.decisions.slice(0, 3).forEach(decision => {
        html += `<li><strong>${decision.title}</strong><br><small>${decision.description || ''}</small></li>`;
      });
      html += "</ul>";
    }
    
    if (analysis.action_items && analysis.action_items.length > 0) {
      html += "<h4>üìù Action Items</h4><ul>";
      analysis.action_items.slice(0, 5).forEach(item => {
        const priority = item.priority === 'high' ? 'üî¥' : item.priority === 'medium' ? 'üü°' : 'üü¢';
        html += `<li>${priority} <strong>${item.task}</strong> (${item.assignee || 'Unassigned'})</li>`;
      });
      html += "</ul>";
    }
    
    if (analysis.speakers && analysis.speakers.length > 0) {
      html += "<h4>üë• Speakers</h4><ul>";
      analysis.speakers.forEach(speaker => {
        html += `<li><strong>${speaker.name}</strong> - ${speaker.role || 'Participant'} (${Math.round(speaker.engagement * 100)}% engaged)</li>`;
      });
      html += "</ul>";
    }
    
    html += "</div>";
    
    analysisContent.innerHTML = html;
    analysisResults.style.display = "block";
  }

  // Event handlers
  analyzeBtn.onclick = analyzeConversation;
  createDiagramBtn.onclick = createMiroDiagram;

  function checkZoomUrl() {
    const url = meetingUrl.value.trim().toLowerCase();
    if (url.includes('zoom.us') || url.includes('zoom.com')) {
      zoomBanner.style.display = "block";
    } else {
      zoomBanner.style.display = "none";
    }
  }

  function saveMeetingUrl() {
    const url = meetingUrl.value.trim();
    if (url) {
      localStorage.setItem('attendee_meeting_url', url);
    }
  }

  function loadMeetingUrl() {
    const savedUrl = localStorage.getItem('attendee_meeting_url');
    if (savedUrl) {
      meetingUrl.value = savedUrl;
      checkZoomUrl(); // Check if it's a Zoom URL
    }
  }

  // Load saved URL on page load
  loadMeetingUrl();

  // Check for Zoom URL and save when user types
  meetingUrl.addEventListener('input', () => {
    checkZoomUrl();
    saveMeetingUrl();
  });
  meetingUrl.addEventListener('paste', () => {
    setTimeout(() => {
      checkZoomUrl();
      saveMeetingUrl();
    }, 0);
  });
  </script>
</body>
</html>

